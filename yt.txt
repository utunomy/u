

push 
pop

キュー
入れた順に出てくるいれもの　(ロケットえんぴつ)
次の2つの操作からなるデータ構造をキュー (Queue) と呼ぶ
(1) キューにデータを新たに追加すると (Enqueue) それがキューの最後の要素となる
(2) キューからデータを取り出すときは (Dequeue) はじめに入れたものから選ばれる
こういった一方向性を待ち行列とか先入れ先だし (Fist In First Out，FIFO) と呼ぶ．また後入れ先だしのもの，スタックなどは後入れ先だし (Last In First Out，ＬＩＦＯ) と呼ぶ

順位キュー
優先度が高い順で出てくるキュー
データは優先度が大小で比較できるような数値，キー値をもつ
キューに新たなデータが追加される度に最上値 (最優先データ) が導出される
最上値の導出は多くの場合ソーティングによって実行される
キューの特殊な形として，連続するDequeueが返す値が必ず単調増加である場合，これを単調順位キュー (Monotone Priority Queue) と呼ぶ

2項木
2項木 Bk は次のように再帰的に定義される
B0 は節点を1つだけからなる木
Bk は 2つの Bk-1 2項木を連結してできた木で，一方の木の根がもう一方の木の根の「最左の子」として加えられる

k = lg n は2項木の高さと根の次数である
2項木は全部で 2^k 個の節点をもつ
高さ h の節点数は kCh で計算できる
根は最大次数の節点であり，根の子に右から 0，1，．．．，k-1 という番号を付けると 子i は部分木 Bi の根である

2項ヒープ
次の2項ヒープ条件 (Binomial-heap Property) を満たす2項木の集合 H が2項ヒープ (Binomial-heap) である
i．H に属する2項木は全て最小ヒープ条件を満足する．
　最小ヒープ条件を満足する木は 最小ヒープで順序づけられているという
ii．H には同じ高さの2項木がない (次数 k の根をもつ木は1つしか存在しない)
2項ヒープがもてる2項木の数は高々 lg n + 1 個である

2項ヒープのマージ
次のプロセスでマージされた2項木 H' をつくる
i．2つの2項木 H1，H2 の根リスト (連結リスト) をマージして新たな根リスト R' をつくる～
ii．R' をもとに (2項ヒープ条件を満たすよう) 集合 H' を再構成する
マージ直後の R' には同じ高さの木が2つある可能性がある (ii の過程で最大3つ発生)
これからの説明では R' のマージは昇順と考える

＜P:Bk T:B1 N:B1＞
2項木 T と N を連結する

＜P:B1 T:B1 N:Bk＞
連結
＜P，R，N＞
H' は 2つの2項木 R，N を連結してできた木で，
根が最小値の方の木を親として連結する
＜R+N＞
R が N の「最左の子」として加えられるとして
P に根がないとき Head[H'] が更新される事に注意してほしい

＜R=Bk N1=Bk N2 = Bk＞
R と N1 が同次数のとき，次の分岐が存在する
a) R，N1，N2 が同次数のとき R を N1 の位置に進める
　(N2 の次は必ず別の次数である)
b) N2 の次数が R，N1 と異なるとき R と N1 を連結する

＜R=B0 N=B1＞
R を N の位置に進める

フィボナッチヒープ
2項ヒープを改善したもので，ならし解析において優秀なスコア
兄弟関係を双方向連結リストで表現している
要素の追加、削除により2項木の再構成が必要になるが，
再構成は実際に値が取り出されるそのときにやる (遅延実行)

基数ヒープ
＜図＞
単調増加キューに用いられるADT
データをいくつかの幅のあるバケツに分散する
幅ありバケツは決まった間隔で並べられており，容量が順に 1，1，2，4，8，16，．．．となるように作られる
C = 最大の辺の長さ + 1 として
FindMin と Insert を O(lgC) ならし時間で，DecreaseKey を O(1) 時間で実現する
ダイクストラのアルゴリズムを V = 頂点数として O(VlgC) で計算する

2分探索木
＜図＞
次に示す2分探索木条件 (Binary-search-tree Property) を満たす2分木を2分探索木と呼ぶ
親ノード全ての値が「左の子の値 ≦ 親の値 ≦ 右の子の値」の順序となる
n 個のキーをもとに構築した2分探索木は高さ lg n である
キーの検索，追加，削除や，先行点，後続点の計算には全て O(lg n) かかる．
節点全ての巡回には O(n) かかる

集合
＜図＞
2分探索木は順序付き有限集合を表現している
次のような手順で，木の中を最小値から昇順に辿ることができる．
0．最小値 (最左のノード) から開始する
1．現在のノード
2．ノードの親
3． 1．に戻るのだが，「親の右部分木がもつ最小値」から開始する
i 番目の要素の取り出しは O(lg n) 操作である

平衡2分探索木
AVL木
赤黒木
Treap
乱択化2分探索木 (RBST)
2分探索木にノードを追加していくとき，木構造が一方に偏ってしまう．
左右の部分木が，偏りなく配置されている木を平衡木と呼ぶ．

回転
＜図＞
(子を2つ3つ付けかえるだけ)
2分探索木の大小関係は保たれる
回転による平衡化は最悪 O(lg n) 時間かかる

AVL木
根の子に対し，左右の深さが 1以下の誤差に抑えられた平衡木．

2色木
次の5つを2色木条件 (Red-Black Tree Property) と呼ぶ
・節点の色は黒か赤
・根は黒
・葉は黒
・節点からその任意子孫の葉までの経路に含まれる黒節点の数は等しい
・赤の子は共に黒である
2色木条件を満たす平衡木を2色木と呼ぶ
根の子の内高さがより高い部分木が「低い部分木の2倍より小さい」
 (セグメント木同様に) 値は全て葉に保持することで，併合，分割，コピー操作をサポートするよう拡張できる．詳細．http://algoogle.hadrori.jp/algorithm/rbtree_merge.html

順序統計量
「その値は 2分探索木が表す集合において何番目の値なのか」という問い合わせを順序統計量 (Order Stastics) と呼ぶ
木の中の部分木全てがもつ内点の個数 (葉のとき 1個) を，根それぞれが保持する．そのような2分探索木を順序統計木と呼ぶ．
select: i 番目の値をもつ節点 x を返す
rank: 節点 x の順序統計量 i を返す

擬似コード
  // T: 2色木
  // size: 内点の数
  // x: 根が開始点
  // i: 順序統計量
  select(x，i)
    r = size[left[x]] + 1
    if (r = i)
      then return x
    if (r < i)
      then select(left[x]，i)
      else select(right[x]，r - i)
  // 順序統計木版 2色木の rotate 関数
  // d: 子の向き 0: 左 1: 右
  // reft-rotate: d is 0，x is y.parent
  // right-rotate: d is 1，y is x.parent
  rotate(x，d)
    r = 1 - d // 反転
    y = x.child[r]
    x.child[r] = y.child[d]
    if (y.child[d] != nil) 
      then y.child[d].parent = x
    y.parent = x.parent
    if (x.parent == nil) 
      then T.root = y
      else if (x == x.parent.child[d])
        then x.parent.child[d] = y
        else x.parent.child[r] = y
    y.child[d] = x
    x.parent = y
    y.size = x.size
    x.size = x.child[d].size + x.child[r].size

探索木の探索順で数えあげるため，たとえ同じキーが複数あっても問題なく返す

区間木
区間 [low，high] を扱う2分探索木
各節点は次の値を保持する
low: 閉区間の下限
high: 閉区間の上限
max: 
次の3つの中から最大の値を選ぶ
左の子の max，右の子の max，自身がもつ high 
区間木は low をキーとして構築される
したがって検索操作以外は通常の2分探索木と違いはない

検索操作
区間 [a，b] が重なる節点があるなら返す．ないなら nil を返す
擬似コード
  // r: 閉区間
  search(T，r)
  x = T.root
  while (x != nil かつ (r.high < low または high < r.low)) // 重ならないとき
    if (r.low <= x.left.max)
      then x = x.left
      else x = x.right
  return x

セグメント木
葉全ての深さが同じ2分木を完全2分木と呼ぶ
ある区間における質問操作が可能な完全2分木である
質問は，区間の総和，区間最小値，区間最大値などがある．O(lg n) 操作である
葉の更新は O(lg n) かかる
木は葉にしか値をもたない
セグメント木は探索に葉の線形時間かかる
要素の追加，削除はサポートしない

トリープ
2分探索木 + ヒープ
優先度を持つ2分探索木である
ヒープと同様，ヒープ条件をつねに満たす．
優先度については，値を追加するときに 0から1の間の小数がランダムに決められる
併合，分割は O(lg n) 時間かかる

ランダム化2分探索木 (RBST)
優先度を保持する代わりに，無作為に選ぶ．
Treapでは，併合操作するとき優先度をもとに親を決定したが，RBSTにおける親の決定は実行時計算である．
Treapと違いコピーしたとき，優先度が重複しない．したがって木がコピーできる．

トライ木
＜図＞
葉が文字列をあらわしノードがその1文字を担当する探索木
ノードを状態と見れば決定性有限オートマトン (DFA) = 正規表現
閉路をもたない

基数木
＜図＞
トライ木の拡張
子1つだけからなるノードを短縮して単純になったもの

3分探索木
＜図＞
トライ木 + 2分探索木
親は左の子，真ん中の子，右の子の高々3つをもつ
ノードと記号に対する遷移関数 δ(q，c) があって q の キー値を k とすると，出力は次の3パターンに分けられる
k > c のとき左の子を返す
k = c のとき真ん中の子を返す
k < c のとき右の子を返す
k = c のときのみ次の文字を読み込む
ほかは k = c となる q の探索である
トライ木と同様に基数木のような短縮をほどこせる
平衡木と同様の平衡化を行える


・文字列のクイックソート
                as bbq art boy arc

               ① as を枢軸に分割

        (art, arc)       as       (bbq, boy)

  ② art を枢軸に分割  bbq を枢軸に分割

            (arc)  art | as | bbq (boy)

  ①．as による分割
                 先頭の文字を比較
                      [a]s  =  [a]rt

                 2番目の文字を比較
                      a[s]  =  a[r]t

  ②．art による分割
                 先頭の文字を比較
                      [a]rt  =  [a]rc

                 2番目の文字を比較
                      a[r]t  =  a[r]c

                 3番目の文字を比較
                      ar[t]  =  ar[c]

  分割されるたび先頭文字からの比較となってしまい
  平均時間 O(nlog n) に隠れた定数 m が肥大する

・マルチキークイックソート
  値をピボットを軸に次の3種類に分類する
  ピボットの値 p に対して p より小さい，p と同値，p より大きい の3つ

                      as bbq art boy arc

                      as を枢軸に分割

    ()               ([a]s, [a]rt, [a]rc)       (b[b]q, b[o]y)

  比較文字が衝突したグループは比較文字を2文字目に移す

    ()               (a[s], a[r]t, a[r]c)       (b[b]q, b[o]y)

                  ・・・それぞれ再帰する・・・

  比較は文字ごと，よって比較回数が改善される
  文字列が長いときでも O(nlg n) が安定する

// [1  0  1  1]         0
// [1  0][1  1]      1    2
// [1][0][1][1]   3  4  5  6
// 　　ツリー　　　 添え字
// MakeTree(0, 0, 4) → MakeTree(1, 0, 2), MakeTree(2, 2, 4) 
// T : セグメント木の配列
// A : 値の配列 (簡単のためサイズは偶数とする)
// 節点 T[n] は範囲 first ≦ i ＜ last 内の最小値 min(A[i]) を保持する
MakeTree(n, begin, end)
  first[T[n]] = begin
  last[T[n]] = end - 1
  if (begin ≠ (end - 1))
    then MakeTree((2n + 1), begin, ((begin + end) / 2))
           MakeTree((2n + 2), ((begin + end) / 2), end)

//      _      _
// [1  0  1  1]         0
// [1  0][1  1]      1    2
// [1][0][1][1]   3  4  5  6
// 　　ツリー　　　 添え字
// Query(0, 1, 3) → min(Query(1, 1, 3), Query(2, 1, 3)) 
// Query(1, 1, 3) → min(Query(3, 1, 3), Query(4, 1, 3))
// Query(3, 1, 3) → ∞
// Query(4, 1, 3) → 0
// 範囲 i ≦ r ≦ j から最小値を返す
Query(n, i, j)
if (i < 0 または length[A] <= i) 
  then error 『i が範囲外の値です』
if (j < 0 または length[A] <= j) 
  then error 『j が範囲外の値です』
if (i == j)
  then return Akey[i]
if (i > j)
  then k = i
         i = j
         j = k
if (j < first[n] または last[n] < i)
  then return ∞
if (i <= first[n] かつ last[n] <= j)
  then Tkey[n]
else
  // T[2n + 1] : n の左の子
  min-left = Query((2n + 1), i, j)
  min-right = Query((2n + 2), i, j)
  return min(min-left, min-right)

// [1  0]          0
// [1][0]        1   2      [1, 0]
// 　ツリー　　添え字　　配列
// [1  0  0]            0
// [1  0]  [0]       1   2
// [1][0][0][∞]  3 4  5 6   [1, 0, 0, ∞]
// 　ツリー　　　　　添え字　　　配列
// [1  0  0  1]        0
// [1  0][0  1]     1    2
// [1][0][0][1]   3 4  5 6    [1, 0, 0, 1]
// 　ツリー　　　　添え字　　　　配列
// [1  0  0  1  0]                             0
// [1  0  0  1]      [0]                 1            2
// [1  0][0  1]   [0]  [∞]         3    4      5       6
// [1][0][0][1][0][∞][∞][∞] 7 8 9 10 11 12 13 14  [1, 0, 0, 1, 0, ∞, ∞, ∞]
// 　　　　　ツリー　　　　　　　　　　　　添え字　　　　　　　　　　　配列
// [1  0  0  1  0  1]                         0
// [1  0  0  1]    [0  1]              1            2
// [1  0][0  1] [0  1]  [∞]      3    4      5       6
// [1][0][0][1][0][1][∞][∞] 7 8 9 10 11 12 13 14  [1, 0, 0, 1, 0, 1, ∞, ∞]
// 　　　　　ツリー　　　　　　　　　　　　添え字　　　　　　　　　　配列
// [1  0  0  1  0  1  1]                    0
// [1  0  0  1] [0  1  1]            1            2
// [1  0][0  1][0  1]  [1]       3    4      5       6
// [1][0][0][1][0][1][1][∞] 7 8 9 10 11 12 13 14  [1, 0, 0, 1, 0, 1, 1, ∞]
// 　　　　　ツリー　　　　　　　　　　　　添え字　　　　　　　　　　配列
// [1  0  0  1  0  1  1  1]               　0
// [1  0  0  1] [0  1  1  1]         1            2
// [1  0][0  1][0  1] [1  1]     3    4      5       6
// [1][0][0][1][0][1][1][1] 7 8 9 10 11 12 13 14  [1, 0, 0, 1, 0, 1, 1, 1]
// 　　　　　ツリー　　　　　　　　　　　　添え字　　　　　　　　　　配列
// 節の不足をダミーでうめて完全2分木 (葉の添え字を固定) にする

Update(i, key)
Akey[i] = key
// i は T 上の要素 A[i] の位置
i += length[A] - 1
Tkey[i] = key
while(i > 0)
  do i = (i - 1) / 2
       Tkey[i] = min(Tkey[2i + 1], Tkey[2i + 2])

Add(key)
i = length[A]
// i 挿入点
while(Akey[i - 1] == ∞)
  do i -= 1
Akey[i] = key
length[A] += 1
if (log(length[A]) が整数でないとき)
  then for (i = length[A] upto (pow(2, ceil[log(length[A]]) - 1))
           A[i] = ∞

