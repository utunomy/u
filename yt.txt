

push 
pop

キュー
入れた順に出てくるいれもの　(ロケットえんぴつ)
次の2つの操作からなるデータ構造をキュー (Queue) と呼ぶ
(1) キューにデータを新たに追加すると (Enqueue) それがキューの最後の要素となる
(2) キューからデータを取り出すときは (Dequeue) はじめに入れたものから選ばれる
こういった一方向性を待ち行列とか先入れ先だし (Fist In First Out，FIFO) と呼ぶ．また後入れ先だしのもの，スタックなどは後入れ先だし (Last In First Out，ＬＩＦＯ) と呼ぶ

順位キュー
優先度が高い順で出てくるキュー
データは優先度が大小で比較できるような数値，キー値をもつ
キューに新たなデータが追加される度に最上値 (最優先データ) が導出される
最上値の導出は多くの場合ソーティングによって実行される
キューの特殊な形として，連続するDequeueが返す値が必ず単調増加である場合，これを単調順位キュー (Monotone Priority Queue) と呼ぶ

2項木
2項木 Bk は次のように再帰的に定義される
B0 は節点を1つだけからなる木
Bk は 2つの Bk-1 2項木を連結してできた木で，一方の木の根がもう一方の木の根の「最左の子」として加えられる

k = lg n は2項木の高さと根の次数である
2項木は全部で 2^k 個の節点をもつ
高さ h の節点数は kCh で計算できる
根は最大次数の節点であり，根の子に右から 0，1，．．．，k-1 という番号を付けると 子i は部分木 Bi の根である

2項ヒープ
次の2項ヒープ条件 (Binomial-heap Property) を満たす2項木の集合 H が2項ヒープ (Binomial-heap) である
i．H に属する2項木は全て最小ヒープ条件を満足する．
　最小ヒープ条件を満足する木は 最小ヒープで順序づけられているという
ii．H には同じ高さの2項木がない (次数 k の根をもつ木は1つしか存在しない)
2項ヒープがもてる2項木の数は高々 lg n + 1 個である

2項ヒープのマージ
次のプロセスでマージされた2項木 H' をつくる
i．2つの2項木 H1，H2 の根リスト (連結リスト) をマージして新たな根リスト R' をつくる～
ii．R' をもとに (2項ヒープ条件を満たすよう) 集合 H' を再構成する
マージ直後の R' には同じ高さの木が2つある可能性がある (ii の過程で最大3つ発生)
これからの説明では R' のマージは昇順と考える

＜P:Bk T:B1 N:B1＞
2項木 T と N を連結する

＜P:B1 T:B1 N:Bk＞
連結
＜P，R，N＞
H' は 2つの2項木 R，N を連結してできた木で，
根が最小値の方の木を親として連結する
＜R+N＞
R が N の「最左の子」として加えられるとして
P に根がないとき Head[H'] が更新される事に注意してほしい

＜R=Bk N1=Bk N2 = Bk＞
R と N1 が同次数のとき，次の分岐が存在する
a) R，N1，N2 が同次数のとき R を N1 の位置に進める
　(N2 の次は必ず別の次数である)
b) N2 の次数が R，N1 と異なるとき R と N1 を連結する

＜R=B0 N=B1＞
R を N の位置に進める

フィボナッチヒープ
2項ヒープを改善したもので，ならし解析において優秀なスコア
兄弟関係を双方向連結リストで表現している
要素の追加、削除により2項木の再構成が必要になるが，
再構成は実際に値が取り出されるそのときにやる (遅延実行)

基数ヒープ
＜図＞
単調増加キューに用いられるADT
データはいくつかのヒープ構造をもった幅のあるバケツに分散する
幅ありバケツは一定の間隔で並べられており，容量が順に 1，1，2，4，8，16，．．．となるように作られる
TakeMin と Insert を O(lgC) ならし時間で，DecreaseKey を O(1) 時間で実現する

2分探索木
＜図＞
ノードの値全てが「左の子の値 ≦ 親の値 ≦ 右の子の値」の順序となる2分木を2分探索木と呼ぶ

トライ木
＜図＞
葉が文字列をあらわしノードがその1文字を担当する探索木
ノードを状態と見れば決定性有限オートマトン (DFA) = 正規表現
閉路をもたないDFAを非輪状決定性オートマトン (Acyclic Deterministic Finite Automaton，ADFA) と呼ぶ

基数木
＜図＞
トライ木の拡張
子1つだけからなるノードを短縮して単純になったもの

3分探索木
＜図＞
トライ木 + 2分探索木
親は左の子，真ん中の子，右の子の高々3つをもつ
ノードと記号に対する遷移関数 δ(q，c) があって q の キー値を k とすると，出力は次の3パターンに分けられる
k > c のとき左の子を返す
k = c のとき真ん中の子を返す
k < c のとき右の子を返す
k = c のときのみ次の文字を読み込む
ほかは k = c となる q の探索である
トライ木と同様に基数木のような短縮をほどこせる
平衡木と同様の平衡化を行える


・文字列のクイックソート
                as bbq art boy arc

               ① as を枢軸に分割

        (art, arc)       as       (bbq, boy)

  ② art を枢軸に分割  bbq を枢軸に分割

            (arc)  art | as | bbq (boy)

  ①．as による分割
                 先頭の文字を比較
                      [a]s  =  [a]rt

                 2番目の文字を比較
                      a[s]  =  a[r]t

  ②．art による分割
                 先頭の文字を比較
                      [a]rt  =  [a]rc

                 2番目の文字を比較
                      a[r]t  =  a[r]c

                 3番目の文字を比較
                      ar[t]  =  ar[c]

  分割されるたび先頭文字からの比較となってしまい
  平均時間 O(nlog n) に隠れた定数 m が肥大する

・マルチキークイックソート
  値をピボットを軸に次の3種類に分類する
  ピボットの値 p に対して p より小さい，p と同値，p より大きい の3つ

                      as bbq art boy arc

                      as を枢軸に分割

    ()               ([a]s, [a]rt, [a]rc)       ([b]bq, [b]oy)

  ピボットと同じグループは比較文字を2文字目に移す

    ()               (a[s], a[r]t, a[r]c)       ([b]bq, [b]oy)

                  ・・・それぞれ再帰する・・・

  比較は文字ごと，よって比較回数が改善される
  文字列が長いときでも O(nlg n) が安定する

// [1  0  1  1]         0
// [1  0][1  1]      1    2
// [1][0][1][1]   3  4  5  6
// 　　ツリー　　　 添え字
// MakeTree(0, 0, 4) → MakeTree(1, 0, 2), MakeTree(2, 2, 4) 
// T : セグメント木の配列
// A : 値の配列 (簡単のためサイズは偶数とする)
// 節点 T[n] は範囲 first ≦ i ＜ last 内の最小値 min(A[i]) を保持する
MakeTree(n, begin, end)
  first[T[n]] = begin
  last[T[n]] = end - 1
  if (begin ≠ (end - 1))
    then MakeTree((2n + 1), begin, ((begin + end) / 2))
           MakeTree((2n + 2), ((begin + end) / 2), end)

//      _      _
// [1  0  1  1]         0
// [1  0][1  1]      1    2
// [1][0][1][1]   3  4  5  6
// 　　ツリー　　　 添え字
// Query(0, 1, 3) → min(Query(1, 1, 3), Query(2, 1, 3)) 
// Query(1, 1, 3) → min(Query(3, 1, 3), Query(4, 1, 3))
// Query(3, 1, 3) → ∞
// Query(4, 1, 3) → 0
// 範囲 i ≦ r ≦ j から最小値を返す
Query(n, i, j)
if (i < 0 または length[A] <= i) 
  then error 『i が範囲外の値です』
if (j < 0 または length[A] <= j) 
  then error 『j が範囲外の値です』
if (i == j)
  then return Akey[i]
if (i > j)
  then k = i
         i = j
         j = k
if (j < first[n] または last[n] < i)
  then return ∞
if (i <= first[n] かつ last[n] <= j)
  then Tkey[n]
else
  // T[2n + 1] : n の左の子
  min-left = Query((2n + 1), i, j)
  min-right = Query((2n + 2), i, j)
  return min(min-left, min-right)

// [1  0]          0
// [1][0]        1   2      [1, 0]
// 　ツリー　　添え字　　配列
// [1  0  0]            0
// [1  0]  [0]       1   2
// [1][0][0][∞]  3 4  5 6   [1, 0, 0, ∞]
// 　ツリー　　　　　添え字　　　配列
// [1  0  0  1]        0
// [1  0][0  1]     1    2
// [1][0][0][1]   3 4  5 6    [1, 0, 0, 1]
// 　ツリー　　　　添え字　　　　配列
// [1  0  0  1  0]                             0
// [1  0  0  1]      [0]                 1            2
// [1  0][0  1]   [0]  [∞]         3    4      5       6
// [1][0][0][1][0][∞][∞][∞] 7 8 9 10 11 12 13 14  [1, 0, 0, 1, 0, ∞, ∞, ∞]
// 　　　　　ツリー　　　　　　　　　　　　添え字　　　　　　　　　　　配列
// [1  0  0  1  0  1]                         0
// [1  0  0  1]    [0  1]              1            2
// [1  0][0  1] [0  1]  [∞]      3    4      5       6
// [1][0][0][1][0][1][∞][∞] 7 8 9 10 11 12 13 14  [1, 0, 0, 1, 0, 1, ∞, ∞]
// 　　　　　ツリー　　　　　　　　　　　　添え字　　　　　　　　　　配列
// [1  0  0  1  0  1  1]                    0
// [1  0  0  1] [0  1  1]            1            2
// [1  0][0  1][0  1]  [1]       3    4      5       6
// [1][0][0][1][0][1][1][∞] 7 8 9 10 11 12 13 14  [1, 0, 0, 1, 0, 1, 1, ∞]
// 　　　　　ツリー　　　　　　　　　　　　添え字　　　　　　　　　　配列
// [1  0  0  1  0  1  1  1]               　0
// [1  0  0  1] [0  1  1  1]         1            2
// [1  0][0  1][0  1] [1  1]     3    4      5       6
// [1][0][0][1][0][1][1][1] 7 8 9 10 11 12 13 14  [1, 0, 0, 1, 0, 1, 1, 1]
// 　　　　　ツリー　　　　　　　　　　　　添え字　　　　　　　　　　配列
// 節の不足をダミーでうめて完全2分木 (葉の添え字を固定) にする

Update(i, key)
Akey[i] = key
// i は T 上の要素 A[i] の位置
i += length[A] - 1
Tkey[i] = key
while(i > 0)
  do i = (i - 1) / 2
       Tkey[i] = min(Tkey[2i + 1], Tkey[2i + 2])

Add(key)
i = length[A]
// i 挿入点
while(Akey[i - 1] == ∞)
  do i -= 1
Akey[i] = key
length[A] += 1
if (log(length[A]) が整数でないとき)
  then for (i = length[A] upto (pow(2, ceil[log(length[A]]) - 1))
           A[i] = ∞
