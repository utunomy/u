グラフの探索
幅優先探索 (Breadth First Search，BFS)
G = (V，E) の v ∈ V から到達可能な頂点全てを発見し，始点からの距離 (辺数の最小値) を計算する
始点 s を根とし，到達可能な頂点全てを含むBFS木を構成する．尚，s から各節点への経路は G における最短路を表す
有向グラフにも無向グラフにも適用できる

BFSによる探索例
＜図＞

深さ優先探索 (Depth First Search，DFS)
可能ならば常により深く (隣接の隣接の・・) を探索する
複数のDFS木をから構成されるDFS森を形成する
次の2つの時刻を記録する
d(u)　頂点 u の発見時刻
f(u)　頂点 u の終了時刻
d(u) < f(u) である

DFＳによる探索例
＜図＞

DFSの応用例
・有向グラフを強連結成分に分割する
・トポロジカル・ソート

DFSによる強連結成分の取り出し
G = (V，E) は有向グラフである
DFS(G) を呼び出し，u ∈ V に対し終了時刻 f(u) を計算する
G の転置 (辺を逆に向ける) G' を計算する
DFS(G') を呼び出すのだが，メインループで u∈ V を読み込む所を f(u) の降順にして実行．

// 深さ優先探索
// G : 有向グラフ
DFS(G = (V，E))
each (u ∈ V)
  do color[u] = "White"
time = 0
each (u ∈ V)
  do if (color[u] == "White")
      then DFS(u，time)

DFS(u ∈ V，time)
time += 1
d(u) = time
color[u] = "Glay"
each (v ∈ {u の隣接点 (終点) 全体の集合})
  do if (color[v] == "White")
      then DFS(v，time)
time += 1
f(u) = time
color(u) = "Black"

最小全域木
無向グラフ G = (V，E) があって，G の頂点全てを結合する閉路を含まない T ⊆ E を G の全域木 (Spanning Tree) と呼ぶ
全域木にある辺全てがもつ重みの「合計」が最も小さいものを最小全域木と呼ぶ
c(S，V - S) : カット．V を S ⊆ V と V - S の2つに分割する
辺 (u，v) が u ∈ S，v ∈ {V - S} を満たすとき (u，v) は c(S，V - S) と交差する辺という
軸となる性質
・最小全域木 A ⊆ E とカット c(A，V - A) に対し，A でないもので c(A，V - A) と交差する最小の辺は，A に加えても安全な辺 (最小全域木のまま) である

ダイクストラ
T に最小全域木を構築していく
各辺 (u，v) を昇順で取り出し，T に加えていく．G の頂点を全て結合するまで続く．

プリム
T に最小全域木を構築していく
ある頂点 u に到達する辺の重みを推定値 e(u) として保持し，より小さい辺を更新していく．推定値の初期値は ∞ 
V を推定値を元にキューに入れる．始点の推定値を 0 にする．キューから u を取り出し，隣接点 vi に対し e(u) + w(u，v) が e(v) より小さいとき e(v) を更新する

最短経路問題 (Shortest Path Problem)
単一始点最短経路問題 (Single Source Shortest Path Problem)
始点 u から頂点全てへの最短路を求める問題

単一目的地最短路問題
各頂点から v に向かう最短路を求める．単一始点最短路問題の転置を考えればよい

単一点対最短経路問題
s から t にいたる最短路 p = <s，q2，．．．，qn-1，t> を求める．

全点対最短路問題
すべての頂点からの頂点への最短路全体を求める

トポロジカル・ソート
閉路のない有向グラフ G = (V，E) に対し (u，v) ∈ E のとき u が v より先に表れるような線形順序 (推移的かつ反対称的な) 集合をつくるアルゴリズム
DFSを用いる
・各頂点 v の終了時刻 f(v) を計算するために DFS(G) を呼び出す
・終了した頂点を連結リストの先頭に挿入する
O(V + E) 時間で実行できる

単一始点最短路問題
ベルマン・フォード
＜図＞
一対多の最短路を求めるアルゴリズム
グラフが負の辺をもつときでも問題なく計算できる

ダイクストラ
＜図＞
一対多の最短路を求めるアルゴリズム
グラフが負の辺をもつときは適用できない

一対多の最短路は一対一の最短路をかねている．したがって一対多を求めれば，同時に一対一も完了している．一対多を求めるよりも漸近的に早い一対一アルゴリズムは知られていない (・・はずだ)

重み
G = (V，E) をグラフとして，u，v ∈ V，a = (u，v) は辺である．
重み関数 w(u，v) を |a| と書く
道 p = <a1，a2，．．．，an> に対し 重み関数 w(p) は Σ[k=0，n] w(ak) (重みの合計) と定義する．重み関数 w(p) を |p| と書く

緩和
e[v] : 始点 s から v ∈ (V - s) の (暫定の) 最短路．開始直前の値は ∞ 
e[v] より小さな重みをもつ経路 p が見つかったとき e[v] を更新するが，これを p によって v を緩和するという．
e(v，w) : w < e[v] を満たすとき w によって v を緩和する関数
例．s ∈ V から v ∈ {V - s} に向かう最短路 p = <s，a2，．．．，v> があるとき，e(v，|p|) は p によって v を緩和する．

ベルマンフォード
次の操作を |V| - 1 回繰り返す
・u ∈ V から始まる辺 a1，a2，．．．，an (n ≦ |E|) とその終点 v1，v2，．．．，vn (n < |V|) それぞれに対し，e(vk，e[u] + |ak|) を実行する．
繰り返しが終わったところで，グラフが負の閉路をもつか判定する．
次の条件を満たすとき Ｇ に負の閉路はない
  v ∈ V，A を v の隣接点集合として ∀u ∈ A に対し e[u] + w(u，v) ≧ e[v] である
負の閉路がないとき，アルゴリズムは最短路を導き出している．

ダイクストラ
キュー Q を推定値の集合全体 {e[v] | v ∈ V} から構築する．始点の e[s] に 0 を代入する．
次の操作をキューが空になるまで繰り返す
・キューから最小値 e[u] を取り出す
・最小値 e[u] から始まる辺 a1，a2，．．．，ak (n ≦ |E|) とその終点 v1，v2，．．．，vk (n < |V|) それぞれに対し，e(vk，e[u] + |ak|) を実行する．
繰り返しが終わったところでダイクストラは最短路を導き出している

基数ヒープを用いたダイクストラのキュー
//
//  []    []    []     []      []        []      []  
//  0     1   2-3   4-7  8-15   16-31  ∞
//  0     1     2     3       4         5      
//
C : e ∈ E として max(|e|) + 1 (最大の辺の長さ + 1)
d(v) : 始点 s から v ∈ (V - s) の最短路の長さ (最短距離)
k : log(Vs) バケツの数

基数ヒープ
k 個のバケツをもつ
バケツは区間をもつ
バケツは区間内の値をもつデータを保持する
バケツは区間の短い方から昇順で並ぶ．区間の長さは a = [x，y] ⇒ |a| = y - x で決まる
バケツ i の区間は次のように定義される
b0 = [0，0]
bi = [2^(i - 1)，2^(i) - 1] (i ≧ 1 のとき)

最小値の取り出し
＜図＞
最小の空でないバケツ i を探し，最小値 d を決定する．区間 b0 (最小バケツ) を [d，d] に更新する．i - 1 番目までのバケツに新たに区間を割いていく．尚，バケツ i は消滅してバケツ i - 1 が代わりに担当する．

FindMin
空でない最小のバケツを探すのに O(k) かかる
最小値 d をバケツから探すのに O(1) かかる

Redistribute
値は操作開始直前のバケツ i (最小の空でないバケツ) より左側にあるバケツにしか移らない
値それぞれに新たなバケツの区間を適用するのに O(k) かかる

アルゴリズム全体で O(Ｅ + Vk) = O(Ｅ + VlogVC) = O(Ｅ + VlogC) かかる



