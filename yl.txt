マージ可能ヒープ
MakeHeap(A)
Union(A1，A2)

二項木
二項木 Bk は次のように再帰的に定義される順序木である．
B0 は節点1つだけからなる
Bk は2つの Bk-1 からなるのだが，このとき2つの二項木は，一方の根がもう一方の根の最左の子として連結される．

補題
2^k 個の節点をもつ
k は二項木の高さである
高さ i の節点数は kCi である
節点数 n 個の二項木がもつ節点の最大次数は lg n である

二項ヒープ条件
・二項木の集合 H にある全ての二項木は最小ヒープ条件を満たす
・任意の非負整数 k があって，根の次数が k である二項木は H の中に1つしか存在しない．

p[x] 親の参照
key[x] キー値の参照
child[x] 直接の子の参照
sibling[x] 直接の右隣の兄弟の参照を返す．x が右端のときはNILを返す
degree[x] 節点 x の次数
head[H] 根リストの先頭の根を参照する．2項ヒープが要素を含まないときはNILを返す


Minimum(H)
y = NIL
x = head[H]
min = ∞
while x ≠ NIL
    do if (key[x] < min)
        then min = key[x]
               y = x
         x = sibling[x]
return y

Link(y，smallest)
p[y] = smallest
sibling[y] = child[smallest]
child[smallest] = y
degree[smallest] += 1

Union(H1，H2)
H = MakeHeap()
next = head[H]
while next ≠ NIL
    if (degree[current] ≠ degree[next]) または (sibling[next] ≠ NIL かつ degree[current] = degree[sibling[next]])
        then prev = current
               current = next
        else if (degree[current] <= degree[next])
             then Link(next，current)
                    sibling[current] = sibling[next]
             else if (prev[current] = NIL)
                  then head[H] = next
                         Link(current，next)
                         current = next
         next = sibling[current]
return H


A = (Q，Σ，・・・) をDFAとする
閉路のないDFAを非輪状決定性オートマトン (Acyclic Deterministic Finite Automaton，ADFA) と呼ぶ
q ∈ Q，c ∈ Σ に対し δ(q，c) = δ(q'，c') となる q' ∈ Q，c' ∈ Σ は存在しない (ある状態の一つ前の状態はひとつ)

トライ (Trie)
A = (Q，Σ，・・・) をADFAとする
トライは次の3種類の値から構成される
prev() : ある状態の一つ前の状態を表す．初期状態は prev 値 0 をもつ ．δ(1，a) = 2 ⇔ 1 = prev(2)
key() : Σ → N　文字から一意な数値をつくる．key(#) = 0 (# は終端記号)，key(a) = 1，key(b) = 2
offset() : q ∈ Q，c ∈ Σ のとき offset(q) + key(c) = δ(q，c) (次の状態) を満たす offset(q) をオフセット値と呼ぶ

トライの例
＜図＞
A = ({1，2，3，4，5}，{a，b，c，d}，δ，{1}，{4，5})
prev(1) = 0，prev(2) = 1，prev(3) = 2，prev(4) = 3，prev(5) = 3
key(a) = 1，key(b) = 2，key(c) = 3，key(d) = 4
offset(1) = 1，offset(2) = 1，offset(3) = 1，offset(4) = 1，offset(5) = 2

トライ木
トライ構造 ADFA A を表した木 T をA のトライ木と呼ぶ
・複数の到達点 (枝分かれ) をもつ節点を分岐点と呼ぶ

トライ木の配列による実装
次の3つのメンバーをもつ
BASE配列　offset 値を格納する
CHECK配列　prev 値を格納する
N()　key() と同値
・状態番号と配列のインデックスを対応させる
・葉ノードは BASE の符号を - (マイナス) にして使う
・分岐点でない節点全ては CHECK の符号を - (マイナス) にして使う

CHECK，BASEの実装例
＜図＞
(木・CHECK・BASE・N())
(受理する文字列との対応)
(終端記号ノードいれる)

空要素の連結
トライ木を構築する過程で配列に使われないデータができる
次のようにして CHECK，BASE にできた空要素を連結する
空要素 q1，q2，．．．，qk があるとする
全ての qi は BASE[qi] = CHECK[qi] = q_(i+1) となる値をもつ
・空要素は BASE，CHECK の符号を - (マイナス) にして使う

空要素をもつ配列の例
＜図＞

接尾辞の除去
分岐点のない接尾辞があるとき，トライ木からノードを削除し，木構造をコンパクトにする
TAIL配列　除去した接尾辞を格納する
・分岐点は必ず葉ノードをもつ
・葉ノードは接尾辞を指すインデックスをBASEに保持する

接尾辞除去の例
＜図＞
(接尾辞を持たない葉ノードは従来と変わらない)

配列の再配置
配列にできた空要素が空間を無駄に使用するため，トライ木のノードで置き換える
トライ木にある最大のインデックスのものを最大ノードと呼ぶ
これから説明する条件を満たすとき再配置を行う

自然数全ての集合 N
空要素の集合 E
最大ノードの親 p
p がもつ記号の集合 Σp = {c | c ∈ Σ，CHECK[BASE[p] + c] = p を満たす c}
p がもつ最小値の記号 s = min(c ∈ Σ | CHECK[BASE[p] + c] = p)
p がもつ子ノードの兄弟数 r

条件
b ∈ N，e ∈ E のとき 0 < e - N(s) = b < BASE[p] を満たす b に対し
  a = |CHECK[b + c]| を定義し
  c ∈ Σp，CHECK[a] < 0 である
  または
  r ≠ 2 かつ |Σa| < r である

条件を満たすとき，
・b + c が空要素でなければ配列の末尾に移動する
・最後に BASE[p] + c 全てを b + c に移動する
条件 1 を満たす e が見つからないときは何もしない




