ヒープとは
優先度つきキューとかソートアルゴリズムに用いられる抽象データ型 (ADT)
(プログラミング用語である「ヒープ領域」とは区別する)
おもなもの
二分ヒープ
二項ヒープ
フィボナッチヒープ

二分ヒープ
＜図．二分木＞
おおよそ完全二分木と見なせる二分木

二項ヒープ
＜図．二項木＞
二項木の集合
二分ヒープより素早い O(lg n) マージ操作をサポートする．ただし O(lg n) で最小値を参照する

フィボナッチヒープ
＜図．二項木+＞
二項ヒープよりならし評価が高水準
最短経路問題の処理時間を改善するのに用いられる

ヒープ条件
次のような条件を最小ヒープ条件と呼ぶ
あるノードの子は，親の値より大きな値をもつ．したがって根は常に最小値をもつノードである
(大小関係が最小ヒープ条件と逆さまのものを最大ヒープ条件と呼ぶ)
＜図．最小ヒープ　最大ヒープ＞

二分ヒープ
次のような特徴をもつ二分木である
・ヒープ条件を満たす
・葉は同じ高さで左から順に詰められる
ツリーの表現には配列がよく使われる
ここからしばらくは最小ヒープについて考える

ノードの挿入
ヒープへ新しいノードを挿入する場合，まず挿入点 (IP) に追加する．IPとはそのツリーで最も深い葉で，最も右側にある葉の右隣の位置である．しかし，その位置がツリーからはみ出す場合は，最も左側にある葉の，左側の子の位置である．挿入後はヒープの再構成をする必要がある．「挿入されたノードがもつ値と，その親のノードがもつ値を比較し，順序が逆であれば位置を交換する」という操作を再帰的に繰り返す．
＜図．ＩＰ位置＞

最小値をもつノードの取り出し
ヒープから最小値を取り出す場合，まず根を取り出すと，それが最小値をもつノードである．取り出し後もヒープの再構成をする必要がある．最初に，最終ノード (LN) を根の位置に移動する．次に「根の位置に挿入されたノードがもつ値と，その子のノードがもつ値を比較し，順序が逆であれば位置を交換する」という操作を再帰的に繰り返す．
＜図．ＬＮ例＞

ガウス記号
Floor(i)　i を切り下げる 床関数
Ceil(i)　i を切り上げる 天井関数

最小ヒープ
＜図．ツリー　配列＞
Parent(i)： f(i/2)　親の添え字
Left(i)： 2i　左の子の添え字
Right(i)： 2i + 1　右の子の添え字
高さ： O(lg n)
Length[A]： 配列の長さ
HeapSize[A]　ヒープの容量．A[HeapSize[A]] ＜ A[i] は最小ヒープの要素ではない

次の操作によってヒープソーティングを実現できる
Heapify(A，i)　O(lg n) ノード i のヒープ条件を再帰的に検査し必要ならノードの交換を行う
BuildHeap(A)　O(n) 配列 A をヒープにする
ノードの値と最小値に対し， Length[A] から降順で，「交換する + HeapSizeを1つ下げる」操作を繰り返す．
根の1個手前で操作を終了する，ソーティングは完成している．

Heapify(A，i)
if i > HeapSize[A] 
    then ヒープサイズ・オーバーフロー
l = Left(i)
r = Right(i)
if A[i] > A[l]
    then smallest = l
    else smallest = i
if A[smallest] > A[r]
    then smallest = r
if smallest ≠ i 
    then 値の交換 A[smallest] ⇔ A[i]
    then Heapify(A，smallest)

Heapify の動作
＜図．Heapifyの動作＞

BuildHeap(A)
HeapSize[A] = Length[A]
for i = Floor(Length[A]/2) downto 1
    do Heapify(A，i)
実行時間 Σ[h=0，lg n] n/2^[h+1]O(h) = O(n)

優先度つきキュー
TakeMin(A)　O(lg n) 最小値をもつノード (根) を取り除き値を返す
DecreaseKey(i)　O(lg n) ノード i を元の値よりも小さい値にする
Insert(A，key)　O(lg n) ノードを新たに挿入する
Delete(i)　O(lg n) ノード i をヒープから削除する

TakeMin(A)
min = A[1]
値の交換 A[1] ⇔ A[HeapSize[A]]
HeapSize[A] -= 1
Heapify(A，1)
return min

DecreaseKey(A，i，key)
if A[i] < key 
    then key が i の値よりも大きい
A[i] = key
while i > 1 かつ key < A[Parent(i)]
    then 値の交換 A[i] ⇔ A[Parent(i)]
    then i = Parent(i)

Insert(A，key)
A[HeapSize[A] + 1] = ∞
HeapSize += 1
DecreaseKey(A，HeapSize[A]，key)

Delete(A，i)
DecreaseKey(A，i，-∞)
TakeMin(A)

